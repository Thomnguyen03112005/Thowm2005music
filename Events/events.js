const { ActivityType, EmbedBuilder, PermissionsBitField, InteractionType, ChannelType, ButtonBuilder, ActionRowBuilder, PermissionFlagsBits, Collection, ComponentType, TextInputStyle, ButtonStyle, StringSelectMenuBuilder, ModalBuilder, TextInputBuilder } = require("discord.js");
const { Prefix: prefixSchema, welcomeGoodbye: database, Music: PlayMusicData, afkSchema } = require(`${process.cwd()}/Assets/Schemas/database`);
const { onCoolDown, } = require(`${process.cwd()}/Events/functions`);
const channelSchema = require(`${process.cwd()}/Assets/Schemas/logChannels.js`);
const config = require(`${process.cwd()}/config.json`);
const eventBuilders = require("./Functions/events");
/*========================================================
# create Schema
========================================================*/
const createSchemas = new eventBuilders({
  eventCustomName: "createSchema.js",
  eventName: "ready",
  eventOnce: false,
  executeEvents: async (client) => {
    client.guilds.cache.forEach(async (guild) => {
      const findChannel = await channelSchema.findOne({
        GuildId: guild.id,
      });
      if (!findChannel) return channelSchema.create({
        GuildName: guild.name,
        GuildId: guild.id
      });
    });
    client.guilds.cache.forEach(async (guild) => {
      const Weldata = await database.findOne({
        GuildId: guild.id
      });
      if (!Weldata) return database.create({
        GuildName: guild.name,
        GuildId: guild.id
      });
    });
    client.guilds.cache.forEach(async (guild) => {
      const musicData = await PlayMusicData.findOne({
        GuildId: guild.id
      });
      if (!musicData) return PlayMusicData.create({
        GuildName: guild.name,
        GuildId: guild.id
      });
    });
  },
});
/*========================================================
# Ready.js
========================================================*/
const ready = new eventBuilders({
  eventCustomName: "ready.js",
  eventName: "ready",
  eventOnce: false,
  executeEvents: async (client) => {
    /*========================================================
    # Xem bot ƒë√£ online hay ch∆∞a
    ========================================================*/
    console.log(`${client.user.username} ƒë√£ s·∫µn s√†ng ho·∫°t ƒë·ªông`.red);
    const setActivities = [
      `${client.guilds.cache.size} Guilds, ${client.guilds.cache.map(c => c.memberCount).filter(v => typeof v === "number").reduce((a, b) => a + b, 0)} member`,
      `BlackCat-Club`,
      `${config.prefix}help`
    ];
    setInterval(() => {
      client.user.setPresence({
        activities: [{ name: setActivities[Math.floor(Math.random() * setActivities.length)], type: ActivityType.Playing }],
        status: 'dnd',
      });
    }, 5000);
  },
});
/*========================================================
# messageCreate.js
========================================================*/
const messageCreate = new eventBuilders({
  eventCustomName: "messageCreate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "messageCreate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, message) => {
    if (message.author.bot || !message.guild) return;
    const prefixDT = await prefixSchema.findOne({ GuildId: message.guild.id });
    if (!prefixDT) {
      const newPrefix = new prefixSchema({
        GuildId: message.guild.id,
      });
      await newPrefix.save().catch((e) => {
        console.log("L·ªói:", e);
      });
    };
    const prefix = prefixDT ? prefixDT.Prefix : config.prefix;
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const prefixRegex = new RegExp(`^(<@!?${client.user.id}>|${escapeRegex(prefix)})\\s*`);
    if (!prefixRegex.test(message.content)) return;
    const [matchedPrefix] = message.content.match(prefixRegex);
    if (!message.content.startsWith(matchedPrefix)) return;
    const args = message.content.slice(matchedPrefix.length).trim().split(/ +/g);
    const cmd = args.shift().toLowerCase();
    const mention = new RegExp(`^<@!?${client.user.id}>( |)$`);
    if (message.content.match(mention)) return message.reply({
      embeds: [new EmbedBuilder().setDescription("Prefix c·ªßa t√¥i l√†:" + ` \`${prefix}\``)]
    });
    if (cmd.length === 0) return;
    let command = client.commands.get(cmd);
    if (!command) command = client.commands.get(client.aliases.get(cmd));
    if (command) {
      try {
        const embed = new EmbedBuilder().setTitle("Thi·∫øu quy·ªÅn").setColor("Random")
        if (command.permissions) {
          if (!message.member.permissions.has(PermissionsBitField.resolve(command.permissions || []))) return message.reply({
            embeds: [embed.setDescription(`B·∫°n kh√¥ng c√≥ quy·ªÅn ${command.permissions} ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y`)],
          });
        };
        if (onCoolDown(client.cooldowns, message, command)) return message.reply({
          content: `‚ùå B·∫°n ƒë√£ s·ª≠ d·ª•ng l·ªánh qu√° nhanh vui l√≤ng ƒë·ª£i ${onCoolDown(client.cooldowns, message, command).toFixed()} gi√¢y tr∆∞·ªõc khi s·ª≠ d·ª•ng l·∫°i \`${command.name}\``
        });
        if (command.owner && message.author.id !== config.developer) return message.reply({
          embeds: [embed.setDescription(`B·∫°n kh√¥ng th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y ch·ªâ c√≥ <@${config.developer}> m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng`)]
        });
        if (command.command) {
          command.command(client, message, args, prefix);
        } else {
          command.run(client, message, args, prefix);
        };
      } catch (error) {
        console.log(error.toString());
        message.reply({ content: "L·ªói ƒë√£ ƒë∆∞·ª£c g·ªüi ƒëi :))" });
      };
    } else return message.reply({ content: `Sai l·ªánh. nh·∫≠p ${prefix}help ƒë·ªÉ xem l·∫°i t·∫•t c·∫£ c√°c l·ªánh` }).then((msg) => {
      setTimeout(() => msg.delete(), 10000);
    });
  },
});
/*========================================================
# interactionCreate.js
========================================================*/
const interactionCreate = new eventBuilders({
  eventCustomName: "interactionCreate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "interactionCreate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, interaction) => {
    if (interaction.type === InteractionType.ApplicationCommand) {
      if (!client.slashCommands.has(interaction.commandName) || !interaction.guild) return;
      const SlashCommands = client.slashCommands.get(interaction.commandName);
      if (!SlashCommands) return;
      if (SlashCommands) {
        try {
          const embed = new EmbedBuilder().setTitle("Thi·∫øu quy·ªÅn s·ª≠ d·ª•ng l·ªánh").setColor("Random");
          // dev commands
          if (SlashCommands.owner && config.developer.includes(interaction.user.id)) return interaction.reply({
            content: "T√¥i, kh√¥ng ph·∫£i l√† bot ngu ng·ªëc, ch·ªâ ch·ªß s·ªü h·ªØu m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y"
          });
          // C√°c quy·ªÅn c·ªßa th√†nh vi√™n
          if (SlashCommands.userPerms) {
            if (!interaction.member.permissions.has(PermissionsBitField.resolve(SlashCommands.userPerms || []))) return interaction.reply({
              embeds: [embed.setDescription(`Xin l·ªói, b·∫°n kh√¥ng c√≥ quy·ªÅn ${SlashCommands.userPerms} trong <#${interaction.channelId}> ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh ${SlashCommands.name} n√†y`)]
            });
          };
          SlashCommands.run(client, interaction);
        } catch (error) {
          if (interaction.replied) return await interaction.editReplyinteraction.editReply({
            embeds: [new EmbedBuilder().setDescription("ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh, xin l·ªói v√¨ s·ª± b·∫•t ti·ªán <3")],
            ephemeral: true,
          }).catch(() => { });
          console.log(error);
        };
      };
    };
  },
});
/*========================================================
# guildCreate.js // send messsage 
========================================================*/
const sendMessage = new eventBuilders({
  eventCustomName: "sendMessage", // T√™n events t√πy ch·ªânh
  eventName: "guildCreate", // t√™n events
  eventOnce: false, // b·∫≠t l√™n n·∫øu ch·ªâ th·ª±c hi·ªán n√≥ 1 l·∫ßn
  executeEvents: async (client, guild) => {
    const guilds = await guild.channels.cache.find((channels) => channels.type === ChannelType.GuildText && channels.permissionsFor(guild.members.me).has(PermissionFlagsBits.CreateInstantInvite && PermissionFlagsBits.SendMessages));
    guilds.send({
      embeds: [new EmbedBuilder()
        .setAuthor({ name: guild.name, url: "https://discord.gg/tSTY36dPWa" })
        .setThumbnail("https://i.pinimg.com/originals/3f/2c/10/3f2c1007b4c8d3de7d4ea81b61008ca1.gif")
        .setColor("Random")
        .setTimestamp()
        .setDescription(`‚ú® ${config.prefix}help ƒë·ªÉ xem t·∫•t c·∫£ c√°c l·ªánh`)
        .setFooter({ text: client.user.username, iconURL: client.user.displayAvatarURL({ dynamic: true }) })
      ], components: [new ActionRowBuilder().addComponents([
        new ButtonBuilder().setCustomId('inviteBot').setLabel('M·ªùi bot').setStyle("Primary").setEmoji('üóø'),
        new ButtonBuilder().setCustomId('inviteDiscord').setLabel('V√†o Discord').setStyle("Primary").setEmoji('üè°')
      ])]
    }).catch((e) => console.log(`guildCreate: ${e}`));
  },
});
/*========================================================
# guildCreate.js
========================================================*/
const guildCreate = new eventBuilders({
  eventCustomName: "guildCreate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildCreate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, guild) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);
    // Tin nh·∫Øn g·ª≠i ƒë·∫øn channel m√† bot c√≥ th·ªÉ g·ª≠i. :)) 
    const guilds = await guild.channels.cache.find((channels) => channels.type === ChannelType.GuildText && channels.permissionsFor(guild.members.me).has(PermissionFlagsBits.CreateInstantInvite && PermissionFlagsBits.SendMessages));
    // g·ªüi tin nh·∫Øn v√†o k√™nh nh·∫≠t k√Ω
    database.findOne({ GuildId: guild.id }).then(async (getData) => {
      if (!getData) return;
      const channels = guild.channels.cache.find((channel) => {
        return channel.id === getData.guildCreate;
      });
      if (!channels) return;
      let inviteLink = await guilds.createInvite({ maxAge: 0, maxUses: 0 }).catch(() => { });
      let owner = await guild.fetchOwner();
      // G·ª≠i tin nh·∫Øn v√†o chanel
      return channels.send({
        embeds: [new EmbedBuilder()
          .setAuthor({ name: guild.name, iconURL: owner.user.displayAvatarURL({ dynamic: true }) })
          .setDescription(`T√¥i ƒë√£ th√™m v√†o \`${guild.name}\` v√† t·ªïng s·ªë guild c·ªßa t√¥i l√†: \`${client.guilds.cache.size}\``)
          .addFields([
            { name: `üëë| T√™n ch·ªß s·ªü h·ªØu: `, value: `\`${owner.user.tag}\``, inline: true },
            { name: `üëì| ID ch·ªß s·ªü h·ªØu: `, value: `\`${owner.user.id}\``, inline: true },
            { name: `üë•| T·ªïng s·ªë th√†nh vi√™n:`, value: `\`${guild.members.cache.size}\``, inline: true },
            { name: `üì¨| Link tham gia: `, value: `**${inviteLink ? `${inviteLink}` : "kh√¥ng t·∫°o ƒë∆∞·ª£c :("}**`, inline: true },
            { name: `üÜî| Guild ID:`, value: `**\`${guild.id}\`**`, inline: true },
            { name: `üìÖ| T·∫°o l√∫c:`, value: `**<t:${Date.parse(guild.createdAt) / 1000}:D> | <t:${Date.parse(guild.createdAt) / 1000}:R>**`, inline: true }
          ])
          .setColor("Random")
          .setThumbnail(guild.iconURL({ dynamic: true }))
          .setFooter({ text: client.user.tag, iconURL: client.user.displayAvatarURL({ dynamic: true }) })
          .setTimestamp(Date.now())
        ]
      });
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# guildDelete.js
========================================================*/
const guildDelete = new eventBuilders({
  eventCustomName: "guildDelete.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildDelete", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, guild) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);

    return database.findOne({ GuildId: guild.id, GuildName: guild.name }).then(async (getData) => {
      if (!getData) return;
      const channels = guild.channels.cache.find((channel) => {
        return channel.id === getData.guildDelete;
      });
      if (!channels) return;
      // l·∫•y owner value
      let owner = await guild.fetchOwner();
      // kh·ªüi t·∫°o embeds 
      const embeds = new EmbedBuilder({
        description: `T√¥i ƒë√£ b·ªã kick kh·ªèi \`${guild.name}\` v√† t·ªïng s·ªë guilds c√≤n l·∫°i: \`${client.guilds.cache.size}\``,
        footer: { text: client.user.tag, icon_url: client.user.displayAvatarURL({ dynamic: true }) },
        author: { name: guild.name, icon_url: owner.user.displayAvatarURL({ dynamic: true }) },
        thumbnail: { url: guild.iconURL({ dynamic: true }) },
        timestamp: Date.now(),
        fields: [
          { name: `üëë| T√™n ch·ªß s·ªü h·ªØu: `, value: `\`${owner.user.tag}\``, inline: true },
          { name: `üëì| ID ch·ªß s·ªü h·ªØu: `, value: `\`${owner.user.id}\``, inline: true },
          { name: `üë•| T·ªïng s·ªë th√†nh vi√™n:`, value: `\`${guild.members.cache.size}\``, inline: true },
          { name: `üÜî| Guild ID:`, value: `**\`${guild.id}\`**`, inline: true },
          { name: `üìÖ| t·∫°o l√∫c:`, value: `**<t:${Date.parse(guild.createdAt) / 1000}:D> | <t:${Date.parse(guild.createdAt) / 1000}:R>**`, inline: true }
        ],
      });
      // g·ª≠i tin nh·∫Øn v√†o channel
      return channels.send({ embeds: [embeds] });
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# guildUpdate.js
========================================================*/
const guildUpdate = new eventBuilders({
  eventCustomName: "guildUpdate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildUpdate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, channel) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);

    return database.findOne({ GuildId: channel.guild.id }).then(async (getData) => {
      if (!getData) return;
      const channels = channel.guild.channels.cache.find((_channel) => {
        return _channel.id === getData.channelDelete;
      });
      if (!channels) return;
      if (newGuild.name !== oldGuild.name) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setColor("Yellow")
            .setTitle("Server Updates")
            .addFields({ name: 'T√™n Server ƒë√£ thay ƒë·ªïi', value: `${oldGuild.name} => ${newGuild.name}` })
            .setThumbnail(`${newGuild.iconURL()}`)
            .setTimestamp()
          ]
        });
      } else if (newGuild.iconURL() !== oldGuild.iconURL()) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setColor("Yellow")
            .setTitle("Server Updates")
            .addFields('Avatar c·ªßa server ƒë√£ thay ƒë·ªïi', `[Avatar c≈©](${oldGuild.iconURL()}) => [Avatar m·ªõi](${newGuild.iconURL()})`)
            .setThumbnail(`${newGuild.iconURL()}`)
            .setTimestamp()
          ]
        });
      } else if (newGuild.splashURL() !== oldGuild.splashURL()) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setColor("Yellow")
            .setTitle("Server Updates")
            .addFields({ name: "M√°y ch·ªß Splash ƒë√£ thay ƒë·ªïi", value: `[Splash c≈©](${oldGuild.splashURL()}) => [Splash m·ªõi](${newGuild.splashURL()})` })
            .setThumbnail(`${newGuild.splashURL()}`)
            .setTimestamp()
          ]
        });
      } else if (newGuild.memberCount !== oldGuild.memberCount) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setColor("Yellow")
            .setTitle("Server Updates")
            .addFields({ name: 'Th√†nh vi√™n server ƒë√£ thay ƒë·ªïi', value: `${oldGuild.memberCount} => ${newGuild.memberCount}` })
            .setThumbnail(`${newGuild.iconURL()}`)
            .setTimestamp()
          ]
        });
      } else if (newGuild.ownerId !== oldGuild.ownerId) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setColor("Yellow")
            .setTitle("Server Updates")
            .addFields({ name: 'Ch·ªß s·ªü h·ªØu server ƒë√£ thay ƒë·ªïi', value: `${oldGuild.owner.user.username} => ${newGuild.owner.user.username}` })
            .setThumbnail(`${newGuild.iconURL()}`)
            .setTimestamp()
          ]
        });
      } else {
        return channels.send({
          content: "ƒê√£ s·∫£y ra l·ªói trong qu√° tr√¨nh th·ª±c thi k·∫øt qu·∫£"
        });
      };
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# guildMemberUpdate.js
========================================================*/
const guildMemberUpdate = new eventBuilders({
  eventCustomName: "guildMemberUpdate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildMemberUpdate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, oldMember, newMember) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);

    return database.findOne({ GuildId: oldMember.guild.id }).then(async (getData) => {
      if (!getData) return;
      const channels = oldMember.guild.channels.cache.find((channel) => {
        return channel.id === getData.guildMemberUpdate;
      });
      if (!channels) return;
      if (newMember.nickname !== oldMember.nickname) {
        let oldNickname = oldMember.nickname ? oldMember.nickname : oldMember.user.username;
        let newNickname = newMember.nickname ? newMember.nickname : newMember.user.username;
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle(`${newMember.user.tag}`)
            .addFields({ name: 'Bi·ªát danh th√†nh vi√™n ƒë√£ thay ƒë·ªïi', value: `${oldNickname} => ${newNickname}` })
            .setColor("Yellow")
            .setTimestamp()
            .setThumbnail(`${newMember.user.avatarURL()}`)
          ]
        });
      } else if (newMember.user.username !== oldMember.user.username) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle(`${newMember.user.tag}`)
            .addFields({ name: 'T√™n th√†nh vi√™n ƒë√£ thay ƒë·ªïi', value: `${oldMember.user.username} => ${newMember.user.username}` })
            .setColor("Yellow")
            .setTimestamp()
            .setThumbnail(`${newMember.user.avatarURL()}`)
          ]
        });
      } else if (newMember.user.avatarURL() !== oldMember.user.avatarURL()) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle(`${newMember.user.tag}`)
            .addFields({ name: 'H√¨nh ƒë·∫°i di·ªán th√†nh vi√™n ƒë√£ thay ƒë·ªïi', value: `${oldMember.user.avatarURL()} => ${newMember.user.avatarURL()}` })
            .setColor("Yellow")
            .setTimestamp()
            .setThumbnail(`${newMember.user.avatarURL()}`)
          ]
        });
      } else {
        return channels.send({
          content: "[guildMemberUpdate] ƒê√£ s·∫£y ra l·ªói trong qu√° tr√¨nh th·ª±c thi k·∫øt qu·∫£"
        });
      };
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# voiceStateUpdate.js
========================================================*/
const voiceStateUpdate = new eventBuilders({
  eventCustomName: "voiceStateUpdate.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "voiceStateUpdate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, oldState, newState) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);
    return database.findOne({ GuildId: oldState.guild.id }).then(async (getData) => {
      if (!getData) return;
      const channels = oldState.guild.channels.cache.find((channel) => {
        return channel.id === getData.channelDelete;
      });
      if (!channels) return;
      let oldUser = oldState.member;
      let newUser = newState.member;
      if (oldUser.voice.channelId !== newUser.voice.channelId && newUser.voice.channelId !== null || undefined) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle("Voice State Updates")
            .setDescription(`${newUser} ƒë√£ tham gia k√™nh voice <#${newUser.voice.channelId}>`)
            .setColor("Yellow")
            .setTimestamp()
          ]
        }).catch((ex) => console.log(ex));
      } else if (oldUser.voice.channelId !== newUser.voice.channelId && newUser.voice.channelId === null || undefined) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle("Voice State Updates")
            .setDescription(`${newUser} r·ªùi kh·ªèi k√™nh voice <#${oldUser.voice.channelId}>`)
            .setColor("Yellow")
            .setTimestamp()
          ]
        }).catch((ex) => console.log(ex));
      } else if (oldState.mute !== newState.mute) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle("Voice State Updates")
            .setDescription(`${newUser} ƒë√£ ${newState.mute ? "t·∫Øt ti·∫øng" : "b·∫≠t ti·∫øng"}`)
            .setColor("Yellow")
            .setTimestamp()
          ]
        }).catch((ex) => console.log(ex));
      } else if (oldState.deaf !== newState.deaf) {
        return channels.send({
          embeds: [new EmbedBuilder()
            .setTitle("Voice State Updates")
            .setDescription(`${newUser} ƒë√£ ${newState.deaf ? "t·∫Øt √¢m thanh" : "b·∫≠t √¢m thanh"}`)
            .setColor("Yellow")
            .setTimestamp()
          ]
        }).catch((ex) => console.log(ex));
      };
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# welcome.js
========================================================*/
const welcome = new eventBuilders({
  eventCustomName: "welcome.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildMemberAdd", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, member) => {
    const welcomeData = database.findOne({ GuildId: member.guild.id });
    if (!welcomeData) return;
    const channels = member.guild.channels.cache.find((channel) => {
      return channel.id === welcomeData.WelcomeChannel;
    });
    if (!channels) return;
    channels.send({
      content: `ch√†o m·ª´ng <@${member.user.id}> ƒë√£ ƒë·∫øn v·ªõi ${member.guild.name}`
    });
  },
});
/*========================================================
# guildMemberRemove.js
========================================================*/
const goodbye = new eventBuilders({
  eventCustomName: "goodbye.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "guildMemberRemove", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, member) => {
    const goodbyeData = database.findOne({ GuildId: member.guild.id });
    if (!goodbyeData) return;
    const channels = member.guild.channels.cache.find((channel) => {
      return channel.id === goodbyeData.GoodbyeChannel;
    });
    if (!channels) return;
    channels.send({
      content: `T·∫°m bi·ªát <@${member.user.id}>`
    });
    /*
    return database.findOne({ GuildId: member.guild.id }).then(async(getData) => {
      const Canvas = require('canvas');
      if(!getData) return; // n·∫øu kh√¥ng c√≥ data, return
      const channels = member.guild.channels.cache.find((channel) => {
        return channel.id === getData.GoodbyeChannel;
      });
      if(!channels) return; // n·∫øu kh√¥ng th·∫•y channel, return 
      const canvas = Canvas.createCanvas(1772, 633);     
      const ctx = canvas.getContext('2d');     
      const background = await Canvas.loadImage("https://cdn.discordapp.com/attachments/1055150050357022843/1089624908570566836/welcome.png");
      ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#f2f2f2';
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
      var textString3 = `${member.user.username}`;
      if(textString3.length >= 14) {
        ctx.font = 'bold 100px Genta';
        ctx.fillStyle = '#f2f2f2';
        ctx.fillText(textString3, 720, canvas.height / 2 + 20);
      } else {
        ctx.font = 'bold 150px Genta';
        ctx.fillStyle = '#f2f2f2';
        ctx.fillText(textString3, 720, canvas.height / 2 + 20);
      };
      var textString2 = `#${member.user.discriminator}`;
      ctx.font = 'bold 40px Genta';
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(textString2, 730, canvas.height / 2 + 58);      
      var textString4 = `C√≤n l·∫°i ${member.guild.memberCount} th√†nh vi√™n.`;
      ctx.font = 'bold 60px Genta';
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(textString4, 750, canvas.height / 2 + 125);      
      var textString5 = `${member.guild.name}`;
      ctx.font = 'bold 60px Genta';
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(textString5, 700, canvas.height / 2 - 150);
      ctx.beginPath();
      ctx.arc(315, canvas.height / 2, 250, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.clip();
      const avatar = await Canvas.loadImage(member.user.displayAvatarURL({ extension: "jpg" }));
      ctx.drawImage(avatar, 65, canvas.height / 2 - 250, 500, 500);      
      channels.send({ 
        files: [new AttachmentBuilder(canvas.toBuffer(), { 
          name: 'goodbye-image.png' 
        })]
      }); 
    }).catch((Error) => {
       if(Error) return console.log(Error);
    });
    */
  },
});
/*========================================================
# autoplayMusic.js
========================================================*/
const autoPlayMusic = new eventBuilders({
  eventCustomName: "autoPlayMusic.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "messageCreate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, message) => {
    return PlayMusicData.findOne({ GuildId: message.guild?.id }).then(async (data) => {
      if (!data) return;
      if (!message.guild || !message.guild.available) return;
      if (!data.ChannelId || data.ChannelId.length < 5) return;
      let textChannel = message.guild.channels.cache.get(data.ChannelId) || await message.guild.channels.fetch(data.ChannelId).catch(() => { }) || false;
      if (!textChannel) return console.log("Kh√¥ng c√≥ channel n√†o ƒë∆∞·ª£c thi·∫øt l·∫≠p");
      if (textChannel.id != message.channel.id) return;
      // xo√° tin nh·∫Øn 
      if (message.author.id === client.user.id) {
        setTimeout(() => {
          if (!message.deleted) {
            message.delete().catch(() => { });
          };
        }, 3000);
      } else {
        if (!message.deleted) {
          message.delete().catch((e) => { });
        };
      };
      if (message.author.bot) return;
      // ki·ªÉm tra xem th√†nh vi√™n c√≥ ·ªü trong voice hay kh√¥ng
      if (!await message.member.voice.channel) return message.channel.send({
        content: "B·∫°n c·∫ßn ph·∫£i ·ªü trong m·ªôt k√™nh voice"
      });
      // y√™u c·∫ßu ph√°t nh·∫°c
      await client.distube.play(message.member.voice.channel, message.cleanContent, {
        member: message.member,
        textChannel: message.channel,
        message,
      });
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# musicInteraction.js
========================================================*/
const musicInteraction = new eventBuilders({
  eventCustomName: "musicInteraction.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "interactionCreate", // t√™n s·ª± ki·ªán theo Discord.Events
  eventOnce: false, // kh·ªüi ch·∫°y 1 l·∫ßn 
  executeEvents: async (client, interaction) => {
    if (!interaction.isButton() && !interaction.isStringSelectMenu()) return;
    var { guild, message, channel, member, user, customId } = interaction;
    const data = await PlayMusicData.findOne({ GuildId: interaction.guild.id });
    if (!data) return; // tr·∫£ v·ªÅ n·∫øu kh√¥ng t√¨m th·∫•y data
    if (!guild) guild = client.guilds.cache.get(interaction.guildId);
    if (!guild) return; // tr·∫£ v·ªÅ n·∫øu kh√¥ng t√¨m th·∫•y guilds
    // n·∫øu ch∆∞a setup, return
    if (!data.ChannelId || data.ChannelId.length < 5) return;
    if (!data.MessageId || data.MessageId.length < 5) return;
    // n·∫øu k√™nh kh√¥ng t·ªìn t·∫°i, h√£y th·ª≠ l·∫•y v√† tr·∫£ v·ªÅ n·∫øu v·∫´n kh√¥ng t·ªìn t·∫°i
    if (!channel) channel = guild.channels.cache.get(interaction.channelId);
    if (!channel) return;
    // n·∫øu kh√¥ng ƒë√∫ng k√™nh quay l·∫°i
    if (data.ChannelId != channel.id) return;
    //n·∫øu kh√¥ng ƒë√∫ng tin nh·∫Øn, return
    if (data.MessageId != message.id) return;
    if (!member) member = guild.members.cache.get(user.id);
    if (!member) member = await guild.members.fetch(user.id).catch(() => { });
    if (!member) return;
    // n·∫øu th√†nh vi√™n kh√¥ng ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi voice, return
    if (!member.voice.channel) return interaction.reply({
      content: `**Vui l√≤ng k·∫øt n·ªëi v·ªõi k√™nh voice tr∆∞·ªõc!**`
    });
    let newQueue = client.distube.getQueue(guild.id);
    if (interaction.isButton()) {
      if (!newQueue || !newQueue.songs || !newQueue.songs[0]) return interaction.reply({
        content: "Hi·ªán t·∫°i kh√¥ng ph√°t b√†i h√°t n√†o :))"
      });
      if (customId === "Stop") {
        if (newQueue) {
          await newQueue.stop();
        };
        return interaction.reply({ content: "‚èπ **D·ª´ng ph√°t v√† r·ªùi kh·ªèi K√™nh**" });
      } else if (customId === "Skip") {
        try {
          if (newQueue.songs.length == 0) {
            await newQueue.stop();
            return interaction.reply({ content: "Ng·ª´ng ph√°t v√† r·ªùi kh·ªèi K√™nh" });
          };
          await newQueue.skip();
          return interaction.reply({ content: "‚è≠ **ƒê√£ chuy·ªÉn sang B√†i h√°t ti·∫øp theo!**" });
        } catch (e) {
          return interaction.reply({ content: "B·∫°n ch·ªâ c√≥ 1 b√†i h√°t trong danh s√°ch ph√°t" });
        };
      } else if (customId === "Pause") {
        if (newQueue.paused) {
          newQueue.resume();
          return interaction.reply({ content: "Ti·∫øp t·ª•c ph√°t nh·∫°c" });
        } else {
          await newQueue.pause();
          return interaction.reply({ content: "T·∫°m d·ª´ng ph√°t nh·∫°c" });
        };
      } else if (customId === "Autoplay") {
        newQueue.toggleAutoplay();
        return interaction.reply({ content: `T·ª± ƒë·ªông ph√°t ƒë√£ ƒë∆∞·ª£c ${newQueue.autoplay ? "b·∫≠t" : "t·∫Øt"}` });
      } else if (customId === "Shuffle") {
        client.maps.set(`beforeshuffle-${newQueue.id}`, newQueue.songs.map(track => track).slice(1));
        await newQueue.shuffle();
        return interaction.reply({ content: `ƒê√£ x√°o tr·ªôn ${newQueue.songs.length} b√†i h√°t` });
      } else if (customId === "Song") {
        if (newQueue.repeatMode == 1) {
          await newQueue.setRepeatMode(0);
        } else {
          await newQueue.setRepeatMode(1);
        };
        return interaction.reply({ content: `${newQueue.repeatMode == 1 ? "ƒê√£ b·∫≠t v√≤ng l·∫∑p b√†i h√°t" : "ƒê√£ t·∫Øt v√≤ng l·∫∑p b√†i h√°t"}` });
      } else if (customId === "Queue") {
        if (newQueue.repeatMode == 2) {
          await newQueue.setRepeatMode(0);
        } else {
          await newQueue.setRepeatMode(2);
        };
        return interaction.reply({ content: `${newQueue.repeatMode == 2 ? "ƒê√£ b·∫≠t v√≤ng l·∫∑p h√†ng ƒë·ª£i" : "ƒê√£ t·∫Øt v√≤ng l·∫∑p b√†i h√°t"}` });
      } else if (customId === "Forward") {
        let seektime = newQueue.currentTime + 10;
        if (seektime >= newQueue.songs[0].duration) seektime = newQueue.songs[0].duration - 1;
        await newQueue.seek(seektime);
        return interaction.reply({ content: "ƒê√£ tua b√†i h√°t v·ªÅ tr∆∞·ªõc 10 gi√¢y" });
      } else if (customId === "VolumeUp") {
        try {
          const volumeUp = Number(newQueue.volume) + 10;
          if (volumeUp < 0 || volumeUp > 100) return interaction.reply({
            embeds: [new EmbedBuilder().setColor("Random").setDescription("B·∫°n ch·ªâ c√≥ th·ªÉ ƒë·∫∑t √¢m l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 100.").setTimestamp()], ephemeral: true
          });
          await newQueue.setVolume(volumeUp);
          await interaction.reply({ content: `:white_check_mark: | √Çm l∆∞·ª£ng tƒÉng l√™n ${volumeUp}%` });
        } catch (error) {
          console.log(error);
        };
      } else if (customId === "VolumeDown") {
        try {
          const volumeDown = Number(newQueue.volume) - 10;
          const invalidVolume = new EmbedBuilder().setColor("Random").setDescription(":x: | Kh√¥ng th·ªÉ gi·∫£m √¢m l∆∞·ª£ng c·ªßa b·∫°n n·ªØa n·∫øu ti·∫øp t·ª•c gi·∫£m b·∫°n s·∫Ω kh√¥ng nghe th·∫•y g√¨").setTimestamp();
          if (volumeDown <= 0) return interaction.reply({ embeds: [invalidVolume] });
          await newQueue.setVolume(volumeDown);
          await interaction.reply({ content: `:white_check_mark: | √Çm l∆∞·ª£ng gi·∫£m xu·ªëng ${volumeDown}%` });
        } catch (error) {
          console.log(error);
        };
      } else if (customId === "Rewind") {
        let seektime = newQueue.currentTime - 10;
        if (seektime < 0) seektime = 0;
        if (seektime >= newQueue.songs[0].duration - newQueue.currentTime) seektime = 0;
        await newQueue.seek(seektime);
        return interaction.reply({ content: "ƒê√£ tua b√†i h√°t v·ªÅ sau 10 gi√¢y" });
      } else if (customId === "Lyrics") {
        await interaction.reply({ content: "ƒêang t√¨m ki·∫øm l·ªùi b√†i h√°t", embeds: [], ephemeral: true });
        let thumbnail = newQueue.songs.map((song) => song.thumbnail).slice(0, 1).join("\n");
        let name = newQueue.songs.map((song) => song.name).slice(0, 1).join("\n");
        return interaction.editReply({
          embeds: [new EmbedBuilder()
            .setAuthor({ name: name, iconURL: thumbnail, url: newQueue.songs.map((song) => song.url).slice(0, 1).join("\n") })
            .setColor("Random")
            .setThumbnail(thumbnail)
            .setDescription((await require("lyrics-finder")(newQueue.songs.map((song) => song.uploader.name).slice(0, 1).join("\n"), name)) || "Kh√¥ng t√¨m th·∫•y l·ªùi b√†i h√°t!")
          ], ephemeral: true
        });
      };
      client.updateMusicSystem(newQueue);
    } else if (interaction.isStringSelectMenu()) {
      let link;
      if (interaction.values[0]) {
        //gaming
        if (interaction.values[0].toLowerCase().startsWith(`g`)) link = `https://open.spotify.com/playlist/4a54P2VHy30WTi7gix0KW6`;
        //ncs | no copyrighted music
        if (interaction.values[0].toLowerCase().startsWith(`n`)) link = `https://open.spotify.com/playlist/7sZbq8QGyMnhKPcLJvCUFD`;
      };
      await interaction.reply({ content: `ƒêang t·∫£i **${interaction.values[0]}**`, ephemeral: true });
      try {
        await client.distube.play(member.voice.channel, link, { member: member });
        return interaction.editReply({ content: `${newQueue?.songs?.length > 0 ? "üëç Th√™m v√†o" : "üé∂ ƒêang ph√°t"}: **'${interaction.values[0]}'**`, ephemeral: true });
      } catch (e) {
        console.log(e);
      };
    };
  },
});
/*========================================================
# afkEvent.js
========================================================*/
const afkEvent = new eventBuilders({
  eventCustomName: "afk.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "messageCreate", // t√™n events
  eventOnce: false, // b·∫≠t l√™n n·∫øu ch·ªâ th·ª±c hi·ªán n√≥ 1 l·∫ßn
  executeEvents: async (client, message) => {
    if (message.author.bot) return;
    const afkcheck = await afkSchema.findOne({ GuildId: message.guild.id, UserId: message.author.id });
    if (afkcheck) {
      const nick = afkcheck.Nickname;
      await afkSchema.deleteMany({
        GuildId: message.guild.id,
        UserId: message.author.id
      });
      await message.member.setNickname(`${nick}`).catch((err) => {
        return console.log("Thi·∫øu quy·ªÅn");
      });
      const m1 = await message.reply({ content: `N√†y, b·∫°n ƒë√£ ** tr·ªü l·∫°i **!`, ephemeral: true });
      setTimeout(() => {
        m1.delete();
      }, 10000);
    } else {
      const members = message.mentions.users.first();
      if (!members) return;
      const afkData = await afkSchema.findOne({ GuildId: message.guild.id, UserId: members.id });
      if (!afkData) return;
      const member = message.guild.members.cache.get(members.id);
      const msg = afkData.Message;
      if (message.content.includes(members)) {
        const m = await message.reply({ content: `${member.user.tag} hi·ªán ƒëang AFK\n> **L√Ω do**: ${msg}`, ephemeral: true });
        setTimeout(() => {
          m.delete();
          message.delete();
        }, 10000);
      };
    };
  },
});
/*========================================================
# ticket.js
========================================================*/
const ticket = new eventBuilders({
  eventCustomName: "ticket.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "interactionCreate", // t√™n events
  eventOnce: false, // b·∫≠t l√™n n·∫øu ch·ªâ th·ª±c hi·ªán n√≥ 1 l·∫ßn
  executeEvents: async (client, interaction) => {
    const sourcebin = require("sourcebin_js");
    const settings = {
      ticket: {
        limit: 10,
        categories: {
          name: ""
        },
      },
    };
    const openPerms = ["ManageChannels"];
    const closePerms = ["ManageChannels", "ReadMessageHistory"];
    const isTicketChannel = (channel) => {
      return (channel.type === ChannelType.GuildText && channel.name.startsWith("t—ñcket-") && channel.topic && channel.topic.startsWith("t—ñcket|"));
    };
    const getTicketChannels = (guild) => {
      return guild.channels.cache.filter((ch) => isTicketChannel(ch));
    };
    const getExistingTicketChannel = (guild, userId) => {
      const tktChannels = getTicketChannels(guild);
      return tktChannels.filter((ch) => ch.topic.split("|")[1] === userId).first();
    };
    const closeTicket = async (channel, closedBy, reason) => {
      if (!channel.deletable || !channel.permissionsFor(channel.guild.members.me).has(closePerms)) return "missingPermissions";
      try {
        const messages = await channel.messages.fetch();
        const reversed = Array.from(messages.values()).reverse();
        let content = "";
        reversed.forEach((m) => {
          content += `[${new Date(m.createdAt).toLocaleString("vi-VN")}] - ${m.author.tag}\n`;
          if (m.cleanContent !== "") content += `${m.cleanContent}\n`;
          if (m.attachments.size > 0) content += `${m.attachments.map((att) => att.proxyURL).join(", ")}\n`;
          content += "\n";
        });
        const postToBin = async (content, title = `Nh·∫≠t k√Ω ticket cho ${channel.name}`) => {
          try {
            const response = await sourcebin.create([{ name: " ", content, languageId: "text" }], { title, description: " " });
            return {
              url: response.url,
              short: response.short,
              raw: `https://cdn.sourceb.in/bins/${response.key}/0`,
            };
          } catch (ex) {
            console.log(`postToBin`, ex);
          };
        };
        const logsUrl = await postToBin(content);
        const parseTicketDetails = async (channel) => {
          if (!channel.topic) return;
          const split = channel.topic?.split("|");
          const catName = split[2] || "M·∫∑c ƒë·ªãnh";
          const user = await channel.client.users.fetch(split[1], {
            cache: false
          }).catch(() => { });
          return { user, catName };
        };
        const ticketDetails = await parseTicketDetails(channel);
        const components = [];
        if (logsUrl) {
          components.push(new ActionRowBuilder().addComponents(new ButtonBuilder().setLabel("L·ªãch s·ª≠ tin nh·∫Øn").setURL(logsUrl.short).setStyle(ButtonStyle.Link)));
        };
        if (channel.deletable) await channel.delete();
        const embed = new EmbedBuilder().setAuthor({ name: "ƒê√≥ng Ticket" }).setColor("Red");
        const fields = [];
        if (reason) fields.push({ name: "L√Ω do", value: reason, inline: false });
        fields.push(
          { name: "m·ªü b·ªüi", value: ticketDetails.user ? ticketDetails.user.tag : "Kh√¥ng x√°c ƒë·ªãnh", inline: true },
          { name: "ƒë√≥ng b·ªüi", value: closedBy ? closedBy.tag : "Kh√¥ng x√°c ƒë·ªãnh", inline: true }
        );
        embed.setFields(fields);
        // g·ª≠i Embed cho ng∆∞·ªùi d√πng
        if (ticketDetails.user) {
          ticketDetails.user.send({ embeds: [embed.setDescription(`**T√™n server:** ${channel.guild.name}\n**Th·ªÉ lo·∫°i:** ${ticketDetails.catName}`).setThumbnail(channel.guild.iconURL())], components }).catch((ex) => { });
        };
        return "SUCCESS";
      } catch (ex) {
        console.log("closeTicket", ex);
        return "ERROR";
      };
    };
    const closeAllTickets = async (guild, author) => {
      const channels = getTicketChannels(guild);
      let success = 0, failed = 0;
      for (const ch of channels) {
        const status = await closeTicket(ch[1], author, "Bu·ªôc ƒë√≥ng t·∫•t c·∫£ c√°c ticket ƒëang m·ªü");
        if (status === "SUCCESS") {
          success += 1;
        } else failed += 1;
      };
      return [success, failed];
    };
    const ticketModalSetup = async ({ channel, member }) => {
      const sentMsg = await channel.send({
        content: "Vui l√≤ng b·∫•m v√†o n√∫t b√™n d∆∞·ªõi ƒë·ªÉ thi·∫øt l·∫≠p tin nh·∫Øn ticket",
        components: [new ActionRowBuilder().addComponents(new ButtonBuilder().setCustomId("ticket_btnSetup").setLabel("c√†i ƒë·∫∑t tin nh·∫Øn").setStyle(ButtonStyle.Primary))],
      });
      if (!sentMsg) return;
      const btnInteraction = await channel.awaitMessageComponent({
        componentType: ComponentType.Button,
        filter: (i) => i.customId === "ticket_btnSetup" && i.member.id === member.id && i.message.id === sentMsg.id,
        time: 20000,
      }).catch((ex) => { });
      if (!btnInteraction) return sentMsg.edit({ content: "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi, ƒëang h·ªßy thi·∫øt l·∫≠p", components: [] });
      await btnInteraction.showModal(new ModalBuilder({
        customId: "ticket-modalSetup",
        title: "Thi·∫øt l·∫≠p Ticket",
        components: [
          new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId("title").setLabel("Ti√™u ƒë·ªÅ Embed").setStyle(TextInputStyle.Short).setRequired(false)),
          new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId("description").setLabel("M√¥ t·∫£ Embed").setStyle(TextInputStyle.Paragraph).setRequired(false)),
          new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId("footer").setLabel("Ch√¢n trang Embed").setStyle(TextInputStyle.Short).setRequired(false)),
        ],
      }));
      const modal = await btnInteraction.awaitModalSubmit({
        time: 1 * 60 * 1000,
        filter: (m) => m.customId === "ticket-modalSetup" && m.member.id === member.id && m.message.id === sentMsg.id,
      }).catch((ex) => { });
      if (!modal) return sentMsg.edit({ content: "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi, ƒëang h·ªßy thi·∫øt l·∫≠p", components: [] });
      await modal.reply("Thi·∫øt l·∫≠p tin nh·∫Øn ticket ...");
      await channel.send({
        embeds: [new EmbedBuilder()
          .setColor("Random")
          .setAuthor({ name: modal.fields.getTextInputValue("title") || "Ticket" })
          .setDescription(modal.fields.getTextInputValue("description") || "Vui l√≤ng s·ª≠ d·ª•ng n√∫t b√™n d∆∞·ªõi ƒë·ªÉ t·∫°o ticket")
          .setFooter({ text: modal.fields.getTextInputValue("footer") || "B·∫°n ch·ªâ c√≥ th·ªÉ m·ªü 1 ticket t·∫°i m·ªôt th·ªùi ƒëi·ªÉm!" })
        ],
        components: [new ActionRowBuilder().addComponents(new ButtonBuilder().setLabel("M·ªü ticket").setCustomId("TicketCreate").setStyle(ButtonStyle.Success))]
      });
      await modal.deleteReply();
      await sentMsg.edit({ content: "Xong! ƒê√£ t·∫°o th√¥ng b√°o ticket", components: [] });
    };
    /**  */
    async function close({ channel }, author) {
      if (!isTicketChannel(channel)) return "L·ªánh n√†y ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong k√™nh ticket";
      const status = await closeTicket(channel, author, "ƒê√£ ƒë√≥ng b·ªüi ng∆∞·ªùi ki·ªÉm duy·ªát");
      if (status === "missingPermissions") return "T√¥i kh√¥ng c√≥ quy·ªÅn ƒë√≥ng tickets";
      if (status === "ERROR") return "ƒê√£ x·∫£y ra l·ªói khi ƒë√≥ng ticket";
      return null;
    };
    /**  */
    async function closeAll({ guild }, user) {
      const stats = await closeAllTickets(guild, user);
      return `Xong!, Th√†nh c√¥ng: \`${stats[0]}\` Th·∫•t b·∫°i: \`${stats[1]}\``;
    };
    /**  */
    async function addToTicket({ channel }, inputId) {
      if (!isTicketChannel(channel)) return "L·ªánh n√†y ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong k√™nh ticket";
      if (!inputId || isNaN(inputId)) return "Oops! B·∫°n c·∫ßn nh·∫≠p m·ªôt gi√° tr·ªã h·ª£p l·ªá userId/roleId";
      try {
        await channel.permissionOverwrites.create(inputId, {
          ViewChannel: true,
          SendMessages: true,
        });
        return `ƒê√£ th√™m th√†nh vi√™n <@${inputId}> v√†o ticket`;
      } catch (ex) {
        return "Kh√¥ng th·ªÉ th√™m ng∆∞·ªùi d√πng/Roles. B·∫°n ƒë√£ cung c·∫•p ID h·ª£p l·ªá ch∆∞a?";
      };
    };
    /** */
    async function removeFromTicket({ channel }, inputId) {
      if (!isTicketChannel(channel)) return "L·ªánh n√†y ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong k√™nh ticket";
      if (!inputId || isNaN(inputId)) return "B·∫°n c·∫ßn nh·∫≠p m·ªôt gi√° tr·ªã h·ª£p l·ªá userId/roleId";
      try {
        channel.permissionOverwrites.create(inputId, {
          ViewChannel: false,
          SendMessages: false,
        });
        return "ƒê√£ xo√° th√†nh vi√™n ra kh·ªèi ticket!";
      } catch (ex) {
        return "Kh√¥ng th·ªÉ x√≥a ng∆∞·ªùi d√πng ho·∫∑c roles. B·∫°n c√≥ cung c·∫•p ID h·ª£p l·ªá kh√¥ng?";
      };
    };
    /*========================================================
    # Clicker Handlers
    ========================================================*/
    if (interaction.isButton()) {
      if (interaction.customId === "TicketCreate") {
        await interaction.deferReply({ ephemeral: true });
        const { guild, user } = interaction;
        if (!guild.members.me.permissions.has(openPerms)) return interaction.editReply("Kh√¥ng th·ªÉ t·∫°o k√™nh ticket, thi·∫øu quy·ªÅn `Qu·∫£n l√Ω k√™nh`. H√£y li√™n h·ªá v·ªõi ng∆∞·ªùi qu·∫£n l√Ω m√°y ch·ªß ƒë·ªÉ ƒë∆∞·ª£c tr·ª£ gi√∫p!");
        const alreadyExists = getExistingTicketChannel(guild, user.id);
        if (alreadyExists) return interaction.editReply(`B·∫°n ƒë√£ c√≥ m·ªôt ticket ƒëang m·ªü`);
        // ki·ªÉm tra gi·ªõi h·∫°n
        const existing = getTicketChannels(guild).size;
        if (existing > settings.ticket.limit) return interaction.editReply("C√≥ qu√° nhi·ªÅu ticket ƒëang m·ªü. H√£y th·ª≠ l·∫°i sau");
        // ki·ªÉm tra danh m·ª•c
        let catName = null;
        let catPerms = [];
        const categories = settings.ticket.categories;
        if (categories.length > 0) {
          const options = [];
          settings.ticket.categories.forEach((cat) => options.push({ label: cat.name, value: cat.name }));
          await interaction.editReply({
            content: "Vui l√≤ng ch·ªçn lo·∫°i ticket",
            components: [new ActionRowBuilder().addComponents(new StringSelectMenuBuilder().setCustomId("ticket-menu").setPlaceholder("Ch·ªçn lo·∫°i ticket").addOptions(options))]
          });
          const res = await interaction.channel.awaitMessageComponent({
            componentType: ComponentType.StringSelect,
            time: 60 * 1000,
          }).catch((err) => {
            if (err.message.includes("time")) return;
          });
          if (!res) return interaction.editReply({ content: "H·∫øt gi·ªù. Th·ª≠ l·∫°i", components: [] });
          await interaction.editReply({ content: "X·ª≠ l√Ω", components: [] });
          catName = res.values[0];
          catPerms = categories.find((cat) => cat.name === catName) || [];
        };
        try {
          const permissionOverwrites = [
            { id: guild.roles.everyone, deny: ["ViewChannel"] },
            { id: user.id, allow: ["ViewChannel", "SendMessages", "ReadMessageHistory"] },
            { id: guild.members.me.roles.highest.id, allow: ["ViewChannel", "SendMessages", "ReadMessageHistory"] },
          ];
          if (catPerms?.length > 0) {
            catPerms?.forEach((roleId) => {
              const role = guild.roles.cache.get(roleId);
              if (!role) return;
              permissionOverwrites.push({
                id: role,
                allow: ["ViewChannel", "SendMessages", "ReadMessageHistory"],
              });
            });
          };
          const countTicket = (existing + 1).toString();
          const tktChannel = await guild.channels.create({
            name: `t—ñcket-${countTicket}`,
            type: ChannelType.GuildText,
            topic: `t—ñcket|${user.id}|${catName || "M·∫∑c ƒë·ªãnh"}`,
            permissionOverwrites,
          });
          const sent = await tktChannel.send({
            content: user.toString(),
            embeds: [new EmbedBuilder().setAuthor({ name: `Ticket #${countTicket}` }).setDescription(`Xin ch√†o ${user.toString()}\nNh√¢n vi√™n h·ªó tr·ª£ s·∫Ω ƒë·∫øn v·ªõi b·∫°n trong th·ªùi gian ng·∫Øn\n${catName ? `\n**Lo·∫°i:** ${catName}` : ""}`).setFooter({ text: "B·∫°n c√≥ th·ªÉ ƒë√≥ng ticket c·ªßa m√¨nh b·∫•t c·ª© l√∫c n√†o b·∫±ng c√°ch nh·∫•p v√†o n√∫t b√™n d∆∞·ªõi" })],
            components: [new ActionRowBuilder().addComponents(new ButtonBuilder().setLabel("H·ªßy Ticket").setCustomId("TicketClose").setEmoji("üîí").setStyle(ButtonStyle.Primary))]
          });
          user.send({
            embeds: [new EmbedBuilder().setColor("Random").setAuthor({ name: "Ticket Created" }).setThumbnail(guild.iconURL()).setDescription(`**M√°y ch·ªß:** ${guild.name}\n${catName ? `**Lo·∫°i:** ${catName}` : ""}`)],
            components: [new ActionRowBuilder().addComponents(new ButtonBuilder().setLabel("Xem k√™nh ticket").setURL(sent.url).setStyle(ButtonStyle.Link))]
          }).catch((ex) => { });
          await interaction.editReply({
            content: `ƒê√£ t·∫°o Ticket! h√£y b·∫•m v√†o n√∫t b√™n d∆∞·ªõi ƒë·ªÉ di chuy·ªÉn ƒë·∫øn k√™nh c·ªßa b·∫°n üé´, sau 5 gi√¢y tin nh·∫Øn s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c xo√°`,
            components: [new ActionRowBuilder().addComponents(new ButtonBuilder().setLabel("xem k√™nh ticket").setURL(sent.url).setStyle(ButtonStyle.Link).setEmoji("1091770710915022858"))],
          }).then(() => setTimeout(() => interaction.deleteReply(), 5000));
        } catch (ex) {
          console.log(ex);
          return interaction.editReply("Kh√¥ng th·ªÉ t·∫°o k√™nh ticket, ƒë√£ x·∫£y ra l·ªói!");
        };
      } else if (interaction.customId === "TicketClose") {
        await interaction.deferReply({ ephemeral: true });
        const status = await closeTicket(interaction.channel, interaction.user);
        if (status === "missingPermissions") {
          return interaction.editReply("Kh√¥ng th·ªÉ ƒë√≥ng ticket, thi·∫øu quy·ªÅn. H√£y li√™n h·ªá v·ªõi ng∆∞·ªùi qu·∫£n l√Ω m√°y ch·ªß ƒë·ªÉ ƒë∆∞·ª£c tr·ª£ gi√∫p!");
        } else if (status == "ERROR") {
          return interaction.editReply("Kh√¥ng th·ªÉ ƒë√≥ng v√©, ƒë√£ x·∫£y ra l·ªói!");
        };
      };
    };
    /*========================================================
    # kh·ªüi ch·∫°y c√°c func
    ========================================================*/
    client.ticketModalSetup = ticketModalSetup;
    client.removeFromTicket = removeFromTicket;
    client.addToTicket = addToTicket;
    client.ticketCloseAll = closeAll;
    client.ticketClose = close;
  },
});
/*========================================================
# joinCreateVoice.js
========================================================*/
const joinCreateVoice = new eventBuilders({
  eventCustomName: "joinCreateVoice.js", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "voiceStateUpdate", // t√™n events
  eventOnce: false, // b·∫≠t l√™n n·∫øu ch·ªâ th·ª±c hi·ªán n√≥ 1 l·∫ßn
  executeEvents: async (client, oldState, newState) => {
    const database = require(`${process.cwd()}/Assets/Schemas/logChannels`);
    let voiceManager = new Collection();
    return database.findOne({ GuildId: oldState.guild.id }).then(async (getData) => {
      if (!getData) return;
      const channel = oldState.guild.channels.cache.find((channel) => {
        return channel.id === getData.ChannelAutoCreateVoice;
      });
      if (!channel) return;
      const { member, guild } = oldState;
      const newChannel = newState.channel;
      const oldChannel = oldState.channel;
      if (oldChannel !== newChannel && newChannel && newChannel.id === channel.id) {
        const voiceChannel = await guild.channels.create({
          name: `${member.user.tag}`,
          type: ChannelType.GuildVoice,
          parent: newChannel.parent,
          permissionOverwrites: [
            {
              id: member.id,
              allow: ["Connect", "ManageChannels"],
            },
            {
              id: guild.id,
              allow: ["Connect"],
            },
          ],
          userLimit: 30
        });
        voiceManager.set(member.id, voiceChannel.id);
        await newChannel.permissionOverwrites.edit(member, {
          Connect: false
        });
        setTimeout(() => {
          newChannel.permissionOverwrites.delete(member);
        }, 30000);
        return setTimeout(() => {
          member.voice.setChannel(voiceChannel);
        }, 500);
      };
      const jointocreate = voiceManager.get(member.id);
      const members = oldChannel?.members.filter((m) => !m.user.bot).map((m) => m.id);
      if (jointocreate && oldChannel.id === jointocreate && (!newChannel || newChannel.id !== jointocreate)) {
        if (members.length > 0) {
          let randomID = members[Math.floor(Math.random() * members.length)];
          let randomMember = guild.members.cache.get(randomID);
          randomMember.voice.setChannel(oldChannel).then((v) => {
            oldChannel.setName(randomMember.user.username).catch((e) => null);
            oldChannel.permissionOverwrites.edit(randomMember, {
              Connect: true,
              ManageChannels: true
            });
          });
          voiceManager.set(member.id, null);
          voiceManager.set(randomMember.id, oldChannel.id);
        } else {
          voiceManager.set(member.id, null);
          oldChannel.delete().catch((e) => null);
        };
      };
    }).catch((Error) => {
      if (Error) return console.log(Error);
    });
  },
});
/*========================================================
# discordInteraction.js
========================================================*/
const discordInteraction = new eventBuilders({
  eventCustomName: "buttonCustom", // T√™n s·ª± ki·ªán t√πy ch·ªçn
  eventName: "interactionCreate", // t√™n events
  eventOnce: false, // b·∫≠t l√™n n·∫øu ch·ªâ th·ª±c hi·ªán n√≥ 1 l·∫ßn
  executeEvents: async (client, interaction) => {
    if (interaction.isButton()) {
      if (interaction.customId === "inviteBot") {
        interaction.reply({ content: `[B·∫•m v√†o ƒë√¢y](${config.discordBot})` }).then(() => {
          setTimeout(() => interaction.deleteReply(), 5000);
        }).catch(() => { });
      } else if (interaction.customId === "inviteDiscord") {
        interaction.reply({ content: `[B·∫•m v√†o ƒë√¢y](${config.discord})` }).then(() => {
          setTimeout(() => interaction.deleteReply(), 5000);
        }).catch(() => { });
      };
    };
  },
});

module.exports = [
  createSchemas,
  ready,
  messageCreate,
  interactionCreate,
  guildCreate,
  guildDelete,
  guildUpdate,
  sendMessage,
  guildMemberUpdate,
  voiceStateUpdate,
  discordInteraction,
  musicInteraction,
  joinCreateVoice,
  autoPlayMusic,
  afkEvent,
  welcome,
  goodbye,
  ticket
];